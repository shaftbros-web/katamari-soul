<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Stick-On Battle — 草原版（接着無制限）</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1520; --ink:#e6edf3; --muted:#98a2b3; --accent:#60a5fa;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#0b0f14;color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif;overscroll-behavior:none}
  #wrap{position:fixed;inset:0}
  canvas{position:absolute;inset:0;width:100vw;height:100vh;touch-action:none}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(#0f1520cc,#0f1520cc);padding:16px}
  .card{width:min(980px,96vw);max-height:92vh;overflow:auto;background:var(--panel);border:1px solid #1f2937;border-radius:16px;padding:16px 16px 20px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
  h1{margin:.2em 0;font-size:clamp(22px,4.8vw,36px)}
  .grid{display:grid;gap:12px}
  .grid.cols{grid-template-columns:1fr}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .muted{color:var(--muted);font-size:.95em}
  .btn{appearance:none;border:0;border-radius:12px;background:linear-gradient(180deg,#60a5fa,#2563eb);color:white;padding:12px 16px;font-weight:700;cursor:pointer;box-shadow:0 8px 20px rgba(37,99,235,.35);}
  .btn.secondary{background:#1f2937}
  .btn:active{transform:translateY(1px)}
  label{display:flex;gap:10px;align-items:center;justify-content:space-between;background:#0b1220;border:1px solid #1f2937;border-radius:12px;padding:10px 12px}
  input[type="range"]{width:200px}
  select, input[type="checkbox"]{accent-color:#60a5fa}
  .hidden{display:none !important}

  /* HUD */
  #hud{position:absolute;inset:0;pointer-events:none}
  #hudBar{position:absolute;left:10px;top:10px;display:flex;gap:10px;align-items:center}
  #lifeBar{width:200px;height:14px;border:1px solid #334155;border-radius:999px;background:#0b1220;overflow:hidden}
  #lifeFill{height:100%;background:linear-gradient(90deg,#22c55e,#84cc16);width:100%}
  #wave{font-weight:700}
  #score{font-weight:700;margin-left:8px}
  #combo{margin-left:8px;color:#fbbf24;font-weight:700}
  #hints{position:absolute;left:10px;bottom:10px;color:var(--muted);background:#0b1220cc;padding:6px 8px;border-radius:8px;border:1px solid #1f2937}

  /* 仮想スティック（右下固定） */
  #joy{position:absolute;right:12px;bottom:12px;width:min(34vw,200px);height:min(34vw,200px);touch-action:none;pointer-events:auto}
  .joy-base{position:absolute;inset:0;border-radius:50%;border:2px dashed #334155;background:#0b122088}
  .joy-knob{--r:26%;position:absolute;left:50%;top:50%;width:var(--r);height:var(--r);border-radius:50%;
    transform:translate(-50%,-50%);background:#1f2937;border:2px solid #64748b;box-shadow:0 4px 14px rgba(0,0,0,.45)}

  .big{font-size:clamp(22px,5.2vw,40px);font-weight:900;letter-spacing:.04em}
  .danger{color:#ef4444} .ok{color:#22c55e}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="cv" width="1280" height="720" aria-label="game-canvas"></canvas>

  <!-- HUD -->
  <div id="hud" class="hidden" aria-hidden="true">
    <div id="hudBar">
      <div id="lifeBar"><div id="lifeFill"></div></div>
      <div id="wave">WAVE 1</div>
      <div id="score">SCORE 0</div>
      <div id="combo"></div>
    </div>
    <div id="hints">移動：右下のスティック / くっつけ：アイテムに触れるだけ</div>
  </div>

  <!-- 仮想スティック -->
  <div id="joy" class="hidden" aria-hidden="true">
    <div class="joy-base"></div>
    <div class="joy-knob" id="joyKnob"></div>
  </div>

  <!-- タイトル -->
  <div id="title" class="overlay">
    <div class="card grid">
      <h1>Stick-On Battle — 草原版（接着無制限）</h1>
      <p class="muted">
        ◯△▭をくっつけて敵を迎撃する見下ろしアクション。<br>
        <strong>ノックバック：</strong>◯大 / △なし / ▭小。<strong>接着上限はありません</strong>。<br>
        背景は草原風・チラつき無し。長方形は細長カプセル形状。
      </p>
      <div class="grid cols">
        <label>難易度プリセット
          <span>
            <select id="difficulty">
              <option value="EASY">EASY</option>
              <option value="NORMAL" selected>NORMAL</option>
              <option value="HARD">HARD</option>
            </select>
          </span>
        </label>
        <label>画面シェイク <span><input id="optShake" type="checkbox" checked /></span></label>
        <label>サウンド <span><input id="optSound" type="checkbox" /></span></label>

        <label>アイテム最大数（画面上） <span><output id="oMaxItem">5</output> 個</span>
          <input id="sMaxItem" type="range" min="3" max="8" step="1" value="5" />
        </label>

        <label>敵ライフ倍率 <span><output id="oEnemyHP">1.0</output> x</span>
          <input id="sEnemyHP" type="range" min="0.5" max="3.0" step="0.1" value="1.0" />
        </label>
        <label>アイテム耐久倍率 <span><output id="oItemDur">1.0</output> x</span>
          <input id="sItemDur" type="range" min="0.5" max="3.0" step="0.1" value="1.0" />
        </label>

        <label>敵の出現間隔 <span><output id="oEnemy">900</output> ms</span>
          <input id="sEnemy" type="range" min="250" max="1600" step="50" value="900" />
        </label>
        <label>アイテムの出現間隔 <span><output id="oItem">1100</output> ms</span>
          <input id="sItem" type="range" min="600" max="3000" step="50" value="1100" />
        </label>
        <label>プレイヤー移動速度 <span><output id="oSpeed">260</output> px/s</span>
          <input id="sSpeed" type="range" min="160" max="380" step="10" value="260" />
        </label>
      </div>
      <div class="row">
        <button id="btnStart" class="btn">ゲーム開始</button>
        <button id="btnHow" class="btn secondary" type="button">遊び方</button>
      </div>
      <p id="hiscoreLine" class="muted"></p>
    </div>
  </div>

  <!-- ゲームオーバー -->
  <div id="gameover" class="overlay hidden">
    <div class="card grid" style="text-align:center">
      <div class="big danger">GAME OVER</div>
      <div class="muted">もう一度挑戦してみましょう。</div>
      <div class="row" style="justify-content:center">
        <button id="btnRetry1" class="btn">タイトルへ戻る</button>
        <button id="btnRestart1" class="btn secondary">同じ設定で再開</button>
      </div>
    </div>
  </div>

  <!-- クリア -->
  <div id="clear" class="overlay hidden">
    <div class="card grid" style="text-align:center">
      <div class="big ok">STAGE CLEAR!</div>
      <div id="clearStats" class="muted" style="white-space:pre-line"></div>
      <div class="row" style="justify-content:center">
        <button id="btnRetry2" class="btn">タイトルへ戻る</button>
        <button id="btnRestart2" class="btn secondary">同じ設定で再開</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =====================================================
   接着無制限 / 敵縮小消滅 / HP&耐久スライダー / 草原オフスクリーン描画
===================================================== */
(() => {
  'use strict';

  // ---------- キャンバス ----------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  // 草原オフスクリーン（ちらつき防止：1回生成して使い回し）
  let grassCan = null, grassCtx = null;

  function buildGrass(w,h){
    grassCan = document.createElement('canvas');
    grassCan.width = w; grassCan.height = h;
    grassCtx = grassCan.getContext('2d');

    // 下地グラデ
    const g = grassCtx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#114d2c');
    g.addColorStop(1,'#1f7a3b');
    grassCtx.fillStyle = g;
    grassCtx.fillRect(0,0,w,h);

    // 明暗パッチ（固定乱数シード）
    function srand(i){const x=Math.sin(i*1337.77)*10000; return x-Math.floor(x);}
    grassCtx.globalAlpha = 0.14;
    for (let i=0;i<18;i++){
      const px = srand(i+1)*w, py = srand(i+2)*h;
      const rx = 120 + srand(i+3)*160, ry = 60 + srand(i+4)*120;
      const ang = srand(i+5)*Math.PI*2;
      grassCtx.save();
      grassCtx.translate(px,py); grassCtx.rotate(ang);
      grassCtx.fillStyle = (i%2===0)?'#2aa357':'#0e5e33';
      grassCtx.beginPath();
      grassCtx.ellipse(0,0,rx,ry,0,0,Math.PI*2);
      grassCtx.fill();
      grassCtx.restore();
    }
    grassCtx.globalAlpha = 1;

    // 草の筋（固定間隔）
    grassCtx.strokeStyle = 'rgba(255,255,255,0.05)';
    grassCtx.lineWidth = 1;
    for (let x=0; x<w; x+=40){
      grassCtx.beginPath();
      grassCtx.moveTo(x,0);
      grassCtx.quadraticCurveTo(x+15,h*0.33, x, h*0.66);
      grassCtx.quadraticCurveTo(x-15,h*0.83, x, h);
      grassCtx.stroke();
    }
  }

  function fitCanvas() {
    const w = Math.max(1, Math.floor(window.innerWidth));
    const h = Math.max(1, Math.floor(window.innerHeight));
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.style.width = w + 'px'; cv.style.height = h + 'px';
    cv.width = Math.floor(w * dpr); cv.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    // 草原の再生成（サイズ変更時のみ）
    buildGrass(w, h);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas, {passive:true});
  addEventListener('orientationchange', () => setTimeout(fitCanvas, 100), {passive:true});

  // ---------- DOM ----------
  const hud = document.getElementById('hud');
  const lifeFill = document.getElementById('lifeFill');
  const waveLabel = document.getElementById('wave');
  const scoreLabel = document.getElementById('score');
  const comboLabel = document.getElementById('combo');
  const title = document.getElementById('title');
  const over = document.getElementById('gameover');
  const clear = document.getElementById('clear');
  const joy = document.getElementById('joy');
  const joyKnob = document.getElementById('joyKnob');
  const btnStart = document.getElementById('btnStart');
  const btnHow = document.getElementById('btnHow');
  const btnRetry1 = document.getElementById('btnRetry1');
  const btnRestart1 = document.getElementById('btnRestart1');
  const btnRetry2 = document.getElementById('btnRetry2');
  const btnRestart2 = document.getElementById('btnRestart2');

  const sEnemy = document.getElementById('sEnemy');
  const sItem  = document.getElementById('sItem');
  const sSpeed = document.getElementById('sSpeed');
  const sMaxItem = document.getElementById('sMaxItem');
  const sEnemyHP = document.getElementById('sEnemyHP');
  const sItemDur = document.getElementById('sItemDur');
  const oEnemy = document.getElementById('oEnemy');
  const oItem  = document.getElementById('oItem');
  const oSpeed = document.getElementById('oSpeed');
  const oMaxItem = document.getElementById('oMaxItem');
  const oEnemyHP = document.getElementById('oEnemyHP');
  const oItemDur = document.getElementById('oItemDur');
  const clearStats = document.getElementById('clearStats');
  const hiscoreLine = document.getElementById('hiscoreLine');
  const optShake = document.getElementById('optShake');
  const optSound = document.getElementById('optSound');
  const difficultySel = document.getElementById('difficulty');

  // ---------- ハイスコア ----------
  const LS_KEY = 'stickon_hiscore_v3';
  const hiscore = JSON.parse(localStorage.getItem(LS_KEY) || '{"bestTime":null,"bestKills":0}');
  function setHiscoreLine() {
    if (hiscore.bestTime!=null) {
      hiscoreLine.textContent = `ベスト：${(hiscore.bestTime/1000).toFixed(1)}s / 撃破 ${hiscore.bestKills}`;
    } else {
      hiscoreLine.textContent = 'ベスト：未記録';
    }
  }
  setHiscoreLine();

  // ---------- スライダー同期 ----------
  const bindRange = (range, out, fmt=(v)=>v) => {
    const sync = () => out.textContent = fmt(range.value);
    range.addEventListener('input', sync, {passive:true}); sync();
  };
  bindRange(sEnemy,oEnemy);
  bindRange(sItem,oItem);
  bindRange(sSpeed,oSpeed);
  bindRange(sMaxItem,oMaxItem);
  bindRange(sEnemyHP,oEnemyHP, v=>Number(v).toFixed(1));
  bindRange(sItemDur,oItemDur, v=>Number(v).toFixed(1));

  // ---------- サウンド ----------
  let audioCtx = null;
  function beep(kind='hit'){
    if (!optSound.checked) return;
    try{
      if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.value = (kind==='hit') ? 420 : (kind==='pickup'? 740 : (kind==='dead'? 220 : 520));
      g.gain.value = 0.08;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime + 0.09);
    }catch{}
  }

  // ---------- 入力 ----------
  const input = { x:0, y:0, _active:false, _id:null, _cx:0, _cy:0, _radius:1 };
  function layoutJoystick(){ const r=joy.getBoundingClientRect(); input._cx=r.width/2; input._cy=r.height/2; input._radius=Math.max(30, Math.min(r.width,r.height)*0.38); }
  function stickSet(dx,dy){ const len=Math.hypot(dx,dy), max=input._radius; const nx=len>0?dx/len:0, ny=len>0?dy/len:0, mag=Math.min(len,max);
    joyKnob.style.transform=`translate(${nx*mag}px, ${ny*mag}px) translate(-50%,-50%)`; input.x=(mag/max)*nx; input.y=(mag/max)*ny; }
  function stickReset(){ input.x=input.y=0; joyKnob.style.transform='translate(-50%,-50%)'; }
  joy.addEventListener('pointerdown', (e)=>{ if(input._active)return; input._active=true; input._id=e.pointerId; try{joy.setPointerCapture(e.pointerId);}catch{}
    const r=joy.getBoundingClientRect(); stickSet(e.clientX-(r.left+input._cx), e.clientY-(r.top+input._cy)); e.preventDefault(); });
  joy.addEventListener('pointermove', (e)=>{ if(!input._active||e.pointerId!==input._id)return; const r=joy.getBoundingClientRect();
    stickSet(e.clientX-(r.left+input._cx), e.clientY-(r.top+input._cy)); e.preventDefault(); });
  function endStick(e){ if(!input._active||(e && e.pointerId!==input._id))return; input._active=false; input._id=null; stickReset(); }
  joy.addEventListener('pointerup', endStick); joy.addEventListener('pointercancel', endStick);

  const keys = new Set();
  addEventListener('keydown', e=>{ keys.add(e.key.toLowerCase()); }, {passive:true});
  addEventListener('keyup', e=>{ keys.delete(e.key.toLowerCase()); }, {passive:true});
  function keyboardToStick(){ if(input._active) return; let x=0,y=0;
    if(keys.has('arrowleft')||keys.has('a'))x-=1; if(keys.has('arrowright')||keys.has('d'))x+=1; if(keys.has('arrowup')||keys.has('w'))y-=1; if(keys.has('arrowdown')||keys.has('s'))y+=1;
    const len=Math.hypot(x,y); if(len>0){ input.x=x/len; input.y=y/len; } else { input.x=input.y=0; } }

  // ---------- ユーティリティ ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rnd=(a,b)=>a+Math.random()*(b-a);
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by; return dx*dx+dy*dy;};
  const hit=(ax,ay,ar,bx,by,br)=> dist2(ax,ay,bx,by) <= (ar+br)*(ar+br);
  const clamp01=v=>Math.max(0,Math.min(1,v));

  // ---------- データ ----------
  const ITEM_TYPES = [
    { key:'CIR', name:'◯', shape:'circle', atk:8,  dur:8, baseR:18, color:'#60a5fa', kb:36 },
    { key:'TRI', name:'△', shape:'tri',    atk:16, dur:5, baseR:20, color:'#ff80ab', kb:0  },
    { key:'REC', name:'▭', shape:'rect',   atk:12, dur:3, baseR:16, color:'#ffd166', kb:12, wh:[3.2,0.7] },
  ];
  const ENEMY_TYPES = {
    A:{ hp:10,  dmg:10,  spd:70,  baseR:14, color:'#9b59b6' },
    B:{ hp:16,  dmg:12,  spd:100, baseR:12, color:'#e74c3c' },
    C:{ hp:30,  dmg:16,  spd:50,  baseR:18, color:'#f39c12' },
    MID:{ hp:120, dmg:20, spd:60, baseR:28, color:'#16a085' },
    BOSS:{ hp:360, dmg:28, spd:70, baseR:34, color:'#e67e22' },
  };
  const DIR8 = [[0,-1],[0.707,-0.707],[1,0],[0.707,0.707],[0,1],[-0.707,0.707],[-1,0],[-0.707,-0.707]];
  const WAVES = [
    { name:'WAVE 1', plan:[...'AAAAAAAAAAAA'] },
    { name:'WAVE 2', plan:[...'BBBBBBBBBBBBBB'] },
    { name:'WAVE 3', plan:[...'CCCCCCCCCCCC'] },
    { name:'MID BOSS', plan:['MID'] },
    { name:'WAVE 4', plan:[...'ABACBCABABACABAC'] },
    { name:'BOSS', plan:['BOSS'] },
  ];
  const DIFF = {
    EASY:   { enemySpd:0.9, enemyHP:0.9, spawnMul:1.15 },
    NORMAL: { enemySpd:1.0, enemyHP:1.0, spawnMul:1.00 },
    HARD:   { enemySpd:1.15, enemyHP:1.15, spawnMul:0.9 },
  };

  // ---------- 状態 ----------
  const STATE = { TITLE:0, PLAY:1, OVER:2, CLEAR:3 };
  let state = STATE.TITLE;
  let params = {
    enemyInterval:900, itemInterval:1100, playerSpeed:260,
    maxItems:5, enemyHPmul:1.0, itemDurMul:1.0
  };
  let player, enemies=[], flyingItems=[], attachedItems=[];
  let waveIndex=0, planIndex=0, enemyDirIndex=0, itemDirIndex=0;
  let arrows = []; // 予告矢印
  let timers = { enemy:0, item:0 };
  let time=0, lastT=performance.now();
  let stats = { playTime:0, enemiesDefeated:0, itemsAttached:0, score:0, combo:1, comboT:0 };
  let shake = { t:0, mag:0 };

  // ---------- 予告矢印 ----------
  function addArrow(dir){
    const life = 600;
    const w=cv.clientWidth,h=cv.clientHeight, pad=6;
    const [dx,dy]=DIR8[dir%8]; let x=(dx>0)?(w-pad):((dx<0)?pad:w/2), y=(dy>0)?(h-pad):((dy<0)?pad:h/2);
    arrows.push({x,y,dir,life});
  }

  // ---------- スポーン ----------
  function edgePos(dir) {
    const w = cv.clientWidth, h = cv.clientHeight;
    const margin = 30;
    const [dx,dy] = DIR8[dir%8];
    let x = (dx>0) ? w+margin : (dx<0 ? -margin : rnd(0,w));
    let y = (dy>0) ? h+margin : (dy<0 ? -margin : rnd(0,h));
    if (dx===0){ x = rnd(0,w); } if (dy===0){ y = rnd(0,h); }
    return {x,y};
  }
  function spawnEnemy(key){
    const dir = (enemyDirIndex++)%8;
    addArrow(dir);
    const p = edgePos(dir);
    const t0 = ENEMY_TYPES[key];
    const d = DIFF[difficultySel.value];
    const hpMul = d.enemyHP * params.enemyHPmul;
    const t = { ...t0, hp: Math.round(t0.hp * hpMul), spd: Math.round(t0.spd*d.enemySpd) };
    enemies.push({
      x:p.x, y:p.y, hp:t.hp, hpMax:t.hp, dmg:t.dmg, spd:t.spd,
      baseR:t.baseR, color:t.color, type:key,
      hitFx:0, phase:'normal', charge:0, dash:0
    });
  }
  function spawnItem(){
    // 画面上の総アイテム数（飛来＋接着）がスライダー設定を超えないように制限
    if (attachedItems.length + flyingItems.length >= params.maxItems) return;
    const dir = (itemDirIndex++)%8;
    const p = edgePos(dir);
    const Tbase = ITEM_TYPES[Math.floor(Math.random()*ITEM_TYPES.length)];
    // 耐久倍率適用
    const T = { ...Tbase, dur: Math.max(1, Math.round(Tbase.dur * params.itemDurMul)) };
    const target = {x:player.x, y:player.y};
    const ang = Math.atan2(target.y - p.y, target.x - p.x);
    const speed = rnd(120, 180);
    flyingItems.push({ x:p.x, y:p.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, type:T, dur:T.dur, bornT:time });
  }
  function currentWave(){ return WAVES[waveIndex]; }
  function advanceSpawn(dt){
    timers.enemy -= dt;
    const wv = currentWave();
    const spMul = DIFF[difficultySel.value].spawnMul;
    if (timers.enemy<=0 && wv && planIndex < wv.plan.length){
      spawnEnemy(wv.plan[planIndex++]);
      timers.enemy += params.enemyInterval * (1/spMul);
    }
    if (wv && planIndex>=wv.plan.length && enemies.length===0){
      waveIndex++; planIndex=0;
      if (waveIndex < WAVES.length) waveLabel.textContent = WAVES[waveIndex].name;
      else finishClear();
    }
    timers.item -= dt;
    if (timers.item<=0){
      spawnItem();
      timers.item += params.itemInterval;
    }
  }

  // ---------- 初期化 ----------
  function applyParamsFromUI(){
    params.enemyInterval = Number(sEnemy.value);
    params.itemInterval  = Number(sItem.value);
    params.playerSpeed   = Number(sSpeed.value);
    params.maxItems      = Number(sMaxItem.value);
    params.enemyHPmul    = Number(sEnemyHP.value);
    params.itemDurMul    = Number(sItemDur.value);
  }
  function resetGame(){
    const w = cv.clientWidth, h = cv.clientHeight;
    player = { x:w/2, y:h/2, r:18, hp:120, hpMax:120, speed:params.playerSpeed, inv:0 };
    enemies.length=0; flyingItems.length=0; attachedItems.length=0; arrows.length=0;
    waveIndex=0; planIndex=0; enemyDirIndex=0; itemDirIndex=0;
    timers.enemy = 600; timers.item = 300;
    stats = { playTime:0, enemiesDefeated:0, itemsAttached:0, score:0, combo:1, comboT:0 };
    time = 0; lastT = performance.now();
    waveLabel.textContent = WAVES[0].name;
    scoreLabel.textContent = 'SCORE 0'; comboLabel.textContent = '';
    spawnItem();
  }

  // ---------- 画面遷移 ----------
  function startGame(){
    applyParamsFromUI();
    resetGame();
    title.classList.add('hidden'); over.classList.add('hidden'); clear.classList.add('hidden');
    hud.classList.remove('hidden'); joy.classList.remove('hidden');
    requestAnimationFrame(()=>{ const r=joy.getBoundingClientRect(); input._cx=r.width/2; input._cy=r.height/2; input._radius=Math.max(30, Math.min(r.width,r.height)*0.38); });
    state = STATE.PLAY;
  }
  function backToTitle(){
    hud.classList.add('hidden'); joy.classList.add('hidden');
    title.classList.remove('hidden'); over.classList.add('hidden'); clear.classList.add('hidden');
    setHiscoreLine();
    state = STATE.TITLE;
  }
  function finishOver(){
    if (state!==STATE.PLAY) return;
    state = STATE.OVER;
    hud.classList.add('hidden'); joy.classList.add('hidden'); over.classList.remove('hidden');
    beep('dead');
  }
  function finishClear(){
    if (state!==STATE.PLAY) return;
    state = STATE.CLEAR;
    hud.classList.add('hidden'); joy.classList.add('hidden'); clear.classList.remove('hidden');
    // ハイスコア保存
    const newTime = stats.playTime, newKills = stats.enemiesDefeated;
    let improved = false;
    if (hiscore.bestTime==null || newTime < hiscore.bestTime){ hiscore.bestTime = newTime; improved=true; }
    if (newKills > hiscore.bestKills){ hiscore.bestKills = newKills; improved=true; }
    if (improved){ localStorage.setItem(LS_KEY, JSON.stringify(hiscore)); }
    clearStats.textContent = `撃破数: ${stats.enemiesDefeated}\nクリア時間: ${(stats.playTime/1000).toFixed(1)}s\n取得アイテム: ${stats.itemsAttached}\nスコア: ${stats.score}\nベスト: ${(hiscore.bestTime/1000).toFixed(1)}s / 撃破 ${hiscore.bestKills}`;
    beep('pickup');
  }

  // ---------- シェイク ----------
  function doShake(mag=6, t=120){
    if (!optShake.checked) return;
    shake.mag = Math.max(shake.mag, mag);
    shake.t = Math.max(shake.t, t);
  }
  function applyShake(){
    if (shake.t<=0) return {ox:0, oy:0};
    return {ox:(Math.random()*2-1)*shake.mag, oy:(Math.random()*2-1)*shake.mag};
  }

  // ---------- アイテム/当たり ----------
  const clampItemR = (base, ratio) => base*(0.6+0.4*ratio);
  function itemRadius(obj){ const T=obj.type; const m=obj.maxDur||T.dur; const ratio=Math.max(0,Math.min(1,obj.dur/m)); return clampItemR(T.baseR, ratio); }
  function attachedWorldPos(ai){ return { x: player.x + ai.offX, y: player.y + ai.offY }; }

  // ---------- 更新 ----------
  function update(dt){
    time += dt; stats.playTime += dt;
    // 入力
    if(!input._active){
      let x=0,y=0;
      if (keys.has('arrowleft')||keys.has('a')) x-=1;
      if (keys.has('arrowright')||keys.has('d')) x+=1;
      if (keys.has('arrowup')||keys.has('w')) y-=1;
      if (keys.has('arrowdown')||keys.has('s')) y+=1;
      const len=Math.hypot(x,y); input.x=len?x/len:0; input.y=len?y/len:0;
    }

    // コンボ減衰
    stats.comboT -= dt; if (stats.comboT<=0){ stats.combo=1; comboLabel.textContent=''; }

    // プレイヤー移動
    const speed = params.playerSpeed;
    player.x = clamp(player.x + input.x * speed * dt/1000, player.r+4, cv.clientWidth - player.r - 4);
    player.y = clamp(player.y + input.y * speed * dt/1000, player.r+4, cv.clientHeight - player.r - 4);
    if (player.inv>0) player.inv -= dt;

    const w = cv.clientWidth, h = cv.clientHeight;

    // 飛来アイテム（マグネット吸着）
    for (let i=flyingItems.length-1;i>=0;i--){
      const it = flyingItems[i];
      const dx = player.x - it.x, dy = player.y - it.y;
      const d = Math.hypot(dx,dy);
      if (d<120){ const ax=(dx/d)*60, ay=(dy/d)*60; it.vx += ax * dt/1000; it.vy += ay * dt/1000; }
      it.x += it.vx * dt/1000; it.y += it.vy * dt/1000;

      const rad = itemRadius(it);
      let touched = hit(it.x,it.y,rad, player.x,player.y,player.r);
      if (!touched){
        for (const ai of attachedItems){
          const pos = attachedWorldPos(ai);
          if (hit(it.x,it.y,rad, pos.x,pos.y, itemRadius(ai))){ touched = true; break; }
        }
      }
      if (touched){ // ★接着上限撤廃
        const ang = Math.atan2(it.y - player.y, it.x - player.x);
        const offLen = player.r + rad + 2;
        attachedItems.push({ type:it.type, dur:it.dur, maxDur:it.type.dur, baseR:it.type.baseR, offX: Math.cos(ang)*offLen, offY: Math.sin(ang)*offLen, hitFx:0 });
        stats.itemsAttached++; beep('pickup');
        flyingItems.splice(i,1);
        continue;
      }
      if (it.x<-140||it.y<-140||it.x>w+140||it.y>h+140) flyingItems.splice(i,1);
    }

    // 敵
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      // BOSS: 溜め→突進
      if (e.type==='BOSS'){
        if (e.phase==='normal'){
          e.charge -= dt;
          if (e.charge<=0){ e.phase='charge'; e.charge=600; }
        }else if (e.phase==='charge'){
          e.charge -= dt;
          if (e.charge<=0){ e.phase='dash'; e.dash=400; e.dashAng = Math.atan2(player.y - e.y, player.x - e.x); }
        }else if (e.phase==='dash'){
          e.dash -= dt; if (e.dash<=0){ e.phase='normal'; e.charge = 1800; }
        }
      }
      // 追跡
      let ang = Math.atan2(player.y - e.y, player.x - e.x);
      let spd = e.spd;
      if (e.type==='BOSS' && e.phase==='dash'){ ang = e.dashAng; spd = e.spd*2.0; }
      if (e.type==='BOSS' && e.phase==='charge'){ spd = e.spd*0.3; }
      e.x += Math.cos(ang) * spd * dt/1000;
      e.y += Math.sin(ang) * spd * dt/1000;
      if (e.hitFx>0) e.hitFx -= dt;

      const eR = enemyRadius(e); // HPで縮小
      // 本体ヒット
      if (hit(e.x,e.y,eR, player.x,player.y,player.r)){
        if (player.inv<=0){
          player.hp -= e.dmg; player.inv = 700;
          if (player.hp<=0){ player.hp=0; finishOver(); return; }
        }
        e.x -= Math.cos(ang)*8; e.y -= Math.sin(ang)*8;
      }

      // 接着アイテムでダメージ
      for (let j=attachedItems.length-1;j>=0;j--){
        const ai = attachedItems[j];
        const pos = attachedWorldPos(ai);
        if (hit(e.x,e.y,eR, pos.x,pos.y,itemRadius(ai))){
          const kb = ai.type.kb;
          e.hp -= ai.type.atk; e.hitFx = 120; beep('hit');
          const ang2 = Math.atan2(e.y - pos.y, e.x - pos.x);
          e.x += Math.cos(ang2)*kb; e.y += Math.sin(ang2)*kb;
          ai.dur -= 1;
          if (ai.dur<=0) attachedItems.splice(j,1);
          if (kb>=30) doShake(6,120);
          // スコア簡易
          stats.comboT = 1200; stats.combo = Math.min(2.0, stats.combo + 0.1);
          comboLabel.textContent = (stats.combo>1.01) ? `COMBO x${stats.combo.toFixed(1)}` : '';
          if (e.hp<=0){
            enemies.splice(i,1); stats.enemiesDefeated++;
            const gain = 10 * (ai.type.atk/8) * stats.combo;
            stats.score += Math.round(gain);
            scoreLabel.textContent = `SCORE ${stats.score}`;
            break;
          }
        }
      }
    }

    // 予告矢印寿命
    for (let k=arrows.length-1;k>=0;k--){ const a=arrows[k]; a.life-=dt; if (a.life<=0) arrows.splice(k,1); }

    // スポーン進行
    advanceSpawn(dt);

    // HUD
    lifeFill.style.width = `${(player.hp/player.hpMax)*100}%`;
  }

  // 敵の半径（HPで縮小：HP0.0→0.4倍まで、HP1.0→1.0倍）
  function enemyRadius(e){
    const ratio = clamp((e.hp/e.hpMax), 0, 1);
    return e.baseR * (0.4 + 0.6*ratio);
  }

  // ---------- 描画 ----------
  function draw(){
    const w=cv.clientWidth,h=cv.clientHeight;
    const shakeOff = applyShake();
    ctx.save(); ctx.translate(shakeOff.ox||0, shakeOff.oy||0);

    // 草原（オフスクリーン描画をそのまま転写）
    if (grassCan) ctx.drawImage(grassCan, 0, 0, w, h);

    // 予告矢印
    for (const a of arrows){
      const alpha = Math.max(0, Math.min(1, a.life/600));
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.translate(a.x, a.y);
      const angle = Math.atan2(DIR8[a.dir][1], DIR8[a.dir][0]);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(-12,-8);
      ctx.lineTo(-12,8);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }

    // 飛来アイテム
    for (const it of flyingItems){ drawItem(it.x,it.y, it.type, it.dur, it.type.dur); }
    // 接着アイテム
    for (const ai of attachedItems){
      const p = attachedWorldPos(ai);
      drawItem(p.x,p.y, ai.type, ai.dur, ai.maxDur);
      ctx.strokeStyle = '#12301c'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(player.x,player.y); ctx.lineTo(p.x,p.y); ctx.stroke();
    }

    // 敵（縮小表示）
    for (const e of enemies){
      const r = enemyRadius(e);
      ctx.save();
      if (e.type==='BOSS' && e.phase==='charge'){
        const s = 0.5 + 0.5*Math.abs(Math.sin(time/80));
        ctx.globalAlpha = s;
      }
      if (e.hitFx>0){
        const t = (e.hitFx/120);
        ctx.shadowColor = `rgba(255,255,255,${0.5*t})`;
        ctx.shadowBlur = 16*t;
      }
      ctx.fillStyle = e.color;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(e.x,e.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();

      // HPバー
      const bw = Math.max(20, r*1.8), bh=6;
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(e.x-bw/2, e.y-r-14, bw, bh);
      const ratio = clamp((e.hp/e.hpMax),0,1);
      ctx.fillStyle='#22c55e'; ctx.fillRect(e.x-bw/2, e.y-r-14, bw*ratio, bh);
      ctx.restore();
    }

    // プレイヤー
    ctx.save();
    if (player.inv>0){ ctx.globalAlpha = 0.35 + 0.65*Math.abs(Math.sin(time/100)); }
    ctx.fillStyle = '#60a5fa';
    ctx.strokeStyle = '#0a1b12'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#1f2937'; ctx.beginPath(); ctx.arc(player.x,player.y,6,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // 右上WAVEラベル
    ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(w-180, 8, 172, 28);
    ctx.fillStyle='#e6edf3'; ctx.font='bold 14px system-ui, sans-serif';
    const label = currentWave() ? currentWave().name : (state===STATE.CLEAR?'CLEAR':'FIN');
    ctx.fillText(label, w-170, 26);

    ctx.restore();
  }

  function drawItem(x,y, T_or_ai, dur, maxDur){
    const T = T_or_ai.type ? T_or_ai.type : T_or_ai;
    const m = T_or_ai.maxDur || T.dur;
    const ratio = clamp((dur/m),0,1);
    const r = T.baseR * (0.6+0.4*ratio);
    ctx.save(); ctx.translate(x,y);
    ctx.shadowColor = T.color; ctx.shadowBlur = 12;
    ctx.fillStyle = T.color; ctx.strokeStyle='#000000'; ctx.lineWidth=3;

    if (T.shape==='circle'){
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }else if (T.shape==='tri'){
      ctx.beginPath(); ctx.moveTo(0,-r); ctx.lineTo(r*0.92,r*0.66); ctx.lineTo(-r*0.92,r*0.66); ctx.closePath(); ctx.fill(); ctx.stroke();
    }else{ // 長方形（さらにロング）
      const wh = T.wh || [3.2,0.7];
      const w = r*wh[0], h = r*wh[1], rr = h/2;
      roundRect(-w/2,-h/2,w,h,rr); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+w-r,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r);
    ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r);
    ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
  }

  // ---------- ループ ----------
  function tick(now){
    const dt = Math.max(0, Math.min(50, now - lastT));
    if (shake.t>0){ shake.t-=dt; if (shake.t<=0){ shake.t=0; shake.mag=0; } }
    if (state===STATE.PLAY){ update(dt); draw(); }
    else { // タイトル/他 も草原を固定描画
      if (grassCan) ctx.drawImage(grassCan, 0, 0, cv.clientWidth, cv.clientHeight);
    }
    lastT = now; requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ---------- ボタン ----------
  btnStart.addEventListener('click', startGame);
  btnHow.addEventListener('click', ()=>{
    alert([
      '■ルール',
      '・アイテム（◯△▭）は接着上限なし。画面上の総アイテム数はスライダーで 3〜8 を設定。',
      '・接着アイテムを敵に当てて攻撃：◯ノックバック大、△なし、▭小。',
      '・敵はダメージで小さくなり、HP0で消滅。敵HP倍率・アイテム耐久倍率はスライダーで変更可。',
      '・敵は全方向から順番に出現。ボスはタメ（白点滅）→突進。',
      '',
      '■操作',
      '・右下の仮想スティックで移動（PCは矢印/WASD）',
      '・タイトルで難易度・シェイク・サウンド・各種スライダーを設定'
    ].join('\n'));
  });
  btnRetry1.addEventListener('click', backToTitle);
  btnRetry2.addEventListener('click', backToTitle);
  btnRestart1.addEventListener('click', startGame);
  btnRestart2.addEventListener('click', startGame);

  // ---------- スクロール誤操作防止 ----------
  document.addEventListener('touchmove', (e)=>{ if (state===STATE.PLAY) e.preventDefault(); }, {passive:false});
})();
</script>
</body>
</html>
