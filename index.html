<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Stick-On Battle — 決定版（起動安定版）</title>
<style>
  :root{--panel:#0f1520;--ink:#e6edf3;--muted:#98a2b3}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#0b0f14;color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif;overscroll-behavior:none}
  #wrap{position:fixed;inset:0}

  /* レイヤー順を明確化 */
  canvas{position:absolute;inset:0;width:100vw;height:100vh;touch-action:none;z-index:0}
  #hud{position:absolute;inset:0;pointer-events:none;z-index:8}
  #joy{position:absolute;right:12px;bottom:12px;width:min(34vw,200px);height:min(34vw,200px);touch-action:none;pointer-events:auto;z-index:9}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(#0f1520cc,#0f1520cc);padding:16px;z-index:20}
  .hidden{display:none !important}

  .card{width:min(980px,96vw);max-height:92vh;overflow:auto;background:var(--panel);border:1px solid #1f2937;border-radius:16px;padding:16px 16px 20px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
  h1{margin:.2em 0;font-size:clamp(22px,4.8vw,36px)}
  .grid{display:grid;gap:12px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .muted{color:var(--muted);font-size:.95em}
  .btn{appearance:none;border:0;border-radius:12px;background:linear-gradient(180deg,#60a5fa,#2563eb);color:white;padding:12px 16px;font-weight:700;cursor:pointer;box-shadow:0 8px 20px rgba(37,99,235,.35)}
  .btn.secondary{background:#1f2937}
  .btn:active{transform:translateY(1px)}
  label{display:flex;gap:10px;align-items:center;justify-content:space-between;background:#0b1220;border:1px solid #1f2937;border-radius:12px;padding:10px 12px}
  input[type="range"]{width:240px} select,input[type="checkbox"]{accent-color:#60a5fa}

  /* HUD */
  #hudBar{position:absolute;left:10px;top:10px;display:flex;gap:10px;align-items:center}
  #lifeBar{width:200px;height:14px;border:1px solid #334155;border-radius:999px;background:#0b1220;overflow:hidden}
  #lifeFill{height:100%;background:linear-gradient(90deg,#22c55e,#84cc16);width:100%}
  #wave{font-weight:700} #score{font-weight:700;margin-left:8px} #combo{margin-left:8px;color:#fbbf24;font-weight:700}

  /* 仮想スティック */
  .joy-base{position:absolute;inset:0;border-radius:50%;border:2px dashed #334155;background:#0b122088}
  .joy-knob{--r:26%;position:absolute;left:50%;top:50%;width:var(--r);height:var(--r);border-radius:50%;transform:translate(-50%,-50%);background:#1f2937;border:2px solid #64748b;box-shadow:0 4px 14px rgba(0,0,0,.45)}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="cv" width="1280" height="720" aria-label="game-canvas"></canvas>

  <!-- HUD -->
  <div id="hud" class="hidden" aria-hidden="true">
    <div id="hudBar">
      <div id="lifeBar"><div id="lifeFill"></div></div>
      <div id="wave">WAVE 1</div>
      <div id="score">SCORE 0</div>
      <div id="combo"></div>
    </div>
  </div>

  <!-- 仮想スティック -->
  <div id="joy" class="hidden" aria-hidden="true">
    <div class="joy-base"></div><div class="joy-knob" id="joyKnob"></div>
  </div>

  <!-- タイトル（初期表示で必ず出す） -->
  <div id="title" class="overlay">
    <div class="card grid">
      <h1>Stick-On Battle — 決定版</h1>
      <p class="muted">
        ◯△▭をくっつけて敵にぶつける見下ろしアクション。<br>
        ノックバックは<strong>インパルス物理</strong>で滑らか／画面外へ出ません。<br>
        アイテムは<strong>アイテムにも接続</strong>（チェーン）。枠色：<b>敵＆プレイヤー=黒 / アイテム=白</b>。
      </p>
      <div class="grid">
        <label>難易度
          <span><select id="difficulty">
              <option value="EASY">EASY</option>
              <option value="NORMAL" selected>NORMAL</option>
              <option value="HARD">HARD</option>
          </select></span>
        </label>
        <label>画面シェイク <span><input id="optShake" type="checkbox" checked></span></label>
        <label>サウンド <span><input id="optSound" type="checkbox"></span></label>

        <label>アイテム総数（画面上） <span><output id="oMaxItem">5</output> 個</span>
          <input id="sMaxItem" type="range" min="3" max="8" step="1" value="5">
        </label>
        <label>敵ライフ倍率 <span><output id="oEnemyHP">1.0</output> x</span>
          <input id="sEnemyHP" type="range" min="0.5" max="3.0" step="0.1" value="1.0">
        </label>
        <label>アイテム耐久倍率 <span><output id="oItemDur">1.0</output> x</span>
          <input id="sItemDur" type="range" min="0.5" max="3.0" step="0.1" value="1.0">
        </label>
        <label>ノックバック倍率 <span><output id="oKBMul">1.0</output> x</span>
          <input id="sKBMul" type="range" min="1" max="10" step="0.1" value="1.0">
        </label>
        <label>敵の出現間隔 <span><output id="oEnemy">900</output> ms</span>
          <input id="sEnemy" type="range" min="250" max="1600" step="50" value="900">
        </label>
        <label>アイテムの出現間隔 <span><output id="oItem">1100</output> ms</span>
          <input id="sItem" type="range" min="600" max="3000" step="50" value="1100">
        </label>
        <label>プレイヤー移動速度 <span><output id="oSpeed">260</output> px/s</span>
          <input id="sSpeed" type="range" min="160" max="380" step="10" value="260">
        </label>
      </div>
      <div class="row">
        <button id="btnStart" class="btn" type="button" aria-label="ゲーム開始">ゲーム開始</button>
        <button id="btnHow" class="btn secondary" type="button">遊び方</button>
      </div>
      <p id="hiscoreLine" class="muted"></p>
    </div>
  </div>

  <!-- 結果オーバーレイ -->
  <div id="gameover" class="overlay hidden" aria-hidden="true">
    <div class="card" style="text-align:center">
      <h2>GAME OVER</h2>
      <p class="muted">もう一度挑戦！</p>
      <div class="row" style="justify-content:center">
        <button id="btnRetry1" class="btn" type="button">タイトルへ</button>
        <button id="btnRestart1" class="btn secondary" type="button">同じ設定で再開</button>
      </div>
    </div>
  </div>
  <div id="clear" class="overlay hidden" aria-hidden="true">
    <div class="card" style="text-align:center">
      <h2>STAGE CLEAR!</h2>
      <pre id="clearStats" class="muted"></pre>
      <div class="row" style="justify-content:center">
        <button id="btnRetry2" class="btn" type="button">タイトルへ</button>
        <button id="btnRestart2" class="btn secondary" type="button">同じ設定で再開</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Stick-On Battle — 起動安定版
   ・タイトルは z-index で常に最前面
   ・初期に必ずタイトル表示（安全ガード）
   ・ゲーム性は「決定版」を踏襲（ノックバック物理／チェーン接着 等）
========================================================= */
(() => {
  'use strict';

  /* ---------- キャンバス & 背景 ---------- */
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  let bgCan=null, bgCtx=null;
  function buildBackground(w,h){
    bgCan=document.createElement('canvas'); bgCan.width=w; bgCan.height=h; bgCtx=bgCan.getContext('2d');
    const g=bgCtx.createLinearGradient(0,0,0,h); g.addColorStop(0,'#114d2c'); g.addColorStop(1,'#1f7a3b');
    bgCtx.fillStyle=g; bgCtx.fillRect(0,0,w,h);
    function srand(i){const x=Math.sin(i*1337.77)*10000; return x-Math.floor(x);}
    bgCtx.globalAlpha=0.14;
    for(let i=0;i<18;i++){
      const px=srand(i+1)*w, py=srand(i+2)*h, rx=120+srand(i+3)*160, ry=60+srand(i+4)*120, ang=srand(i+5)*Math.PI*2;
      bgCtx.save(); bgCtx.translate(px,py); bgCtx.rotate(ang);
      bgCtx.fillStyle=(i%2===0)?'#2aa357':'#0e5e33';
      bgCtx.beginPath(); bgCtx.ellipse(0,0,rx,ry,0,0,Math.PI*2); bgCtx.fill(); bgCtx.restore();
    }
    bgCtx.globalAlpha=1;
    bgCtx.strokeStyle='rgba(255,255,255,0.05)'; bgCtx.lineWidth=1;
    for(let x=0;x<w;x+=40){ bgCtx.beginPath(); bgCtx.moveTo(x,0);
      bgCtx.quadraticCurveTo(x+15,h*0.33,x,h*0.66); bgCtx.quadraticCurveTo(x-15,h*0.83,x,h); bgCtx.stroke(); }
  }
  function fitCanvas(){
    const w=Math.max(1,Math.floor(innerWidth)), h=Math.max(1,Math.floor(innerHeight));
    const dpr=Math.max(1,Math.min(2,devicePixelRatio||1));
    cv.style.width=w+'px'; cv.style.height=h+'px';
    cv.width=Math.floor(w*dpr); cv.height=Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    buildBackground(w,h);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas, {passive:true});
  addEventListener('orientationchange', ()=>setTimeout(fitCanvas,100), {passive:true});

  /* ---------- DOM ---------- */
  const hud=document.getElementById('hud');
  const lifeFill=document.getElementById('lifeFill');
  const waveLabel=document.getElementById('wave');
  const scoreLabel=document.getElementById('score');
  const comboLabel=document.getElementById('combo');
  const title=document.getElementById('title');
  const over=document.getElementById('gameover');
  const clear=document.getElementById('clear');
  const joy=document.getElementById('joy');
  const joyKnob=document.getElementById('joyKnob');

  const btnStart=document.getElementById('btnStart');
  const btnHow=document.getElementById('btnHow');
  const btnRetry1=document.getElementById('btnRetry1');
  const btnRestart1=document.getElementById('btnRestart1');
  const btnRetry2=document.getElementById('btnRetry2');
  const btnRestart2=document.getElementById('btnRestart2');

  const difficultySel=document.getElementById('difficulty');
  const optShake=document.getElementById('optShake');
  const optSound=document.getElementById('optSound');

  const sEnemy=document.getElementById('sEnemy'), oEnemy=document.getElementById('oEnemy');
  const sItem=document.getElementById('sItem'), oItem=document.getElementById('oItem');
  const sSpeed=document.getElementById('sSpeed'), oSpeed=document.getElementById('oSpeed');
  const sMaxItem=document.getElementById('sMaxItem'), oMaxItem=document.getElementById('oMaxItem');
  const sEnemyHP=document.getElementById('sEnemyHP'), oEnemyHP=document.getElementById('oEnemyHP');
  const sItemDur=document.getElementById('sItemDur'), oItemDur=document.getElementById('oItemDur');
  const sKBMul=document.getElementById('sKBMul'), oKBMul=document.getElementById('oKBMul');

  const clearStats=document.getElementById('clearStats');
  const hiscoreLine=document.getElementById('hiscoreLine');

  /* ---------- スライダー表示同期 ---------- */
  const bindRange=(r,o,f=(v)=>v)=>{ const sync=()=>o.textContent=f(r.value); r.addEventListener('input',sync,{passive:true}); sync(); };
  bindRange(sEnemy,oEnemy); bindRange(sItem,oItem); bindRange(sSpeed,oSpeed);
  bindRange(sMaxItem,oMaxItem); bindRange(sEnemyHP,oEnemyHP,v=>(+v).toFixed(1));
  bindRange(sItemDur,oItemDur,v=>(+v).toFixed(1)); bindRange(sKBMul,oKBMul,v=>(+v).toFixed(1));

  /* ---------- サウンド ---------- */
  let audioCtx=null;
  function beep(kind='hit'){
    if(!optSound.checked) return;
    try{
      if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='square'; o.frequency.value=(kind==='hit')?420:(kind==='pickup'?740:(kind==='dead'?220:520));
      g.gain.value=0.08; o.connect(g); g.connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime+0.09);
    }catch{}
  }

  /* ---------- 入力（仮想スティック＋キーボード） ---------- */
  const input={x:0,y:0,active:false,id:null,cx:0,cy:0,rad:1};
  function layoutJoystick(){ const r=joy.getBoundingClientRect(); input.cx=r.width/2; input.cy=r.height/2; input.rad=Math.max(30,Math.min(r.width,r.height)*0.38); }
  function stickSet(dx,dy){ const len=Math.hypot(dx,dy), max=input.rad; const nx=len?dx/len:0, ny=len?dy/len:0, mag=Math.min(len,max);
    joyKnob.style.transform=`translate(${nx*mag}px,${ny*mag}px) translate(-50%,-50%)`; input.x=(mag/max)*nx; input.y=(mag/max)*ny; }
  function stickReset(){ input.x=input.y=0; joyKnob.style.transform='translate(-50%,-50%)'; }
  joy.addEventListener('pointerdown',e=>{ if(input.active)return; input.active=true; input.id=e.pointerId; try{joy.setPointerCapture(e.pointerId);}catch{}
    const r=joy.getBoundingClientRect(); stickSet(e.clientX-(r.left+input.cx), e.clientY-(r.top+input.cy)); e.preventDefault();});
  joy.addEventListener('pointermove',e=>{ if(!input.active||e.pointerId!==input.id)return; const r=joy.getBoundingClientRect();
    stickSet(e.clientX-(r.left+input.cx), e.clientY-(r.top+input.cy)); e.preventDefault();});
  function endStick(e){ if(!input.active||(e && e.pointerId!==input.id))return; input.active=false; input.id=null; stickReset(); }
  joy.addEventListener('pointerup',endStick); joy.addEventListener('pointercancel',endStick);

  const keys=new Set(); addEventListener('keydown',e=>{keys.add(e.key.toLowerCase())},{passive:true}); addEventListener('keyup',e=>{keys.delete(e.key.toLowerCase())},{passive:true});

  /* ---------- ユーティリティ ---------- */
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rnd=(a,b)=>a+Math.random()*(b-a);
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;}
  const hit=(ax,ay,ar,bx,by,br)=> dist2(ax,ay,bx,by) <= (ar+br)*(ar+br);

  /* ---------- タイプ定義 ---------- */
  const ITEM_TYPES=[
    {k:'CIR',shape:'circle', atk:8,  dur:8, baseR:18, color:'#60a5fa', kb:28}, // ◯ ノックバック中
    {k:'TRI',shape:'tri',    atk:16, dur:5, baseR:20, color:'#ff80ab', kb:48}, // △ ノックバック大(強)
    {k:'REC',shape:'rect',   atk:12, dur:3, baseR:15, color:'#ffd166', kb: 8, wh:[0.7,4.8]}, // ▭ ノックバック小（細長い縦）
  ];
  const ENEMY_TYPES={
    A:{ hp:12,  dmg:10,  spd:70,  baseR:14, color:'#9b59b6'},
    B:{ hp:18,  dmg:12,  spd:100, baseR:12, color:'#e74c3c'},
    C:{ hp:30,  dmg:16,  spd:55,  baseR:18, color:'#f39c12'},
    MID:{hp:120, dmg:20, spd:60,  baseR:28, color:'#16a085'},
    BOSS:{hp:360, dmg:28, spd:70, baseR:34, color:'#e67e22'},
  };
  const DIR8=[[0,-1],[0.707,-0.707],[1,0],[0.707,0.707],[0,1],[-0.707,0.707],[-1,0],[-0.707,-0.707]];
  const WAVES=[
    {name:'WAVE 1', plan:Array(12).fill('A')},
    {name:'WAVE 2', plan:Array(14).fill('B')},
    {name:'WAVE 3', plan:Array(12).fill('C')},
    {name:'MID BOSS', plan:['MID']},
    {name:'WAVE 4', plan:'ABACBCABABACABAC'.split('')},
    {name:'BOSS', plan:['BOSS']},
  ];
  const DIFF={EASY:{enemySpd:0.9,enemyHP:0.9,spawnMul:1.15},NORMAL:{enemySpd:1.0,enemyHP:1.0,spawnMul:1.0},HARD:{enemySpd:1.15,enemyHP:1.15,spawnMul:0.9}};

  /* ---------- 状態/パラメータ ---------- */
  const STATE={TITLE:0,PLAY:1,OVER:2,CLEAR:3};
  let state=STATE.TITLE;
  const params={enemyInterval:900,itemInterval:1100,playerSpeed:260,maxItems:5,enemyHPmul:1.0,itemDurMul:1.0,kbMul:1.0};
  function applyParamsFromUI(){
    params.enemyInterval=+sEnemy.value; params.itemInterval=+sItem.value; params.playerSpeed=+sSpeed.value;
    params.maxItems=+sMaxItem.value; params.enemyHPmul=+sEnemyHP.value; params.itemDurMul=+sItemDur.value; params.kbMul=+sKBMul.value;
  }

  /* ---------- ランタイム ---------- */
  let player, enemies, flyingItems, attachedItems, arrows, timers, time, lastT, waveIndex, planIndex, enemyDirIndex, itemDirIndex, stats, shake;

  /* ---------- ハイスコア ---------- */
  const LS_KEY='stickon_hiscore_final_ok';
  const hiscore=JSON.parse(localStorage.getItem(LS_KEY)||'{"bestTime":null,"bestKills":0}');
  function setHiscoreLine(){ hiscoreLine.textContent=(hiscore.bestTime!=null)?`ベスト：${(hiscore.bestTime/1000).toFixed(1)}s / 撃破 ${hiscore.bestKills}`:'ベスト：未記録'; }
  setHiscoreLine();

  /* ---------- 初期化/開始/終了 ---------- */
  function resetRuntime(){
    const w=cv.clientWidth,h=cv.clientHeight;
    player={x:w/2,y:h/2,r:18,hp:120,hpMax:120,inv:0};
    enemies=[]; flyingItems=[]; attachedItems=[]; arrows=[];
    timers={enemy:600,item:300};
    time=0; lastT=performance.now();
    waveIndex=0; planIndex=0; enemyDirIndex=0; itemDirIndex=0;
    stats={playTime:0,enemiesDefeated:0,itemsAttached:0,score:0,combo:1,comboT:0};
    shake={t:0,mag:0};
    waveLabel.textContent=WAVES[0].name; scoreLabel.textContent='SCORE 0'; comboLabel.textContent='';
  }
  function startGame(){
    applyParamsFromUI();
    resetRuntime();
    title.classList.add('hidden');
    over.classList.add('hidden'); clear.classList.add('hidden');
    hud.classList.remove('hidden'); joy.classList.remove('hidden');
    requestAnimationFrame(()=>layoutJoystick());
    state=STATE.PLAY;
  }
  function backToTitle(){
    hud.classList.add('hidden'); joy.classList.add('hidden');
    title.classList.remove('hidden'); over.classList.add('hidden'); clear.classList.add('hidden');
    setHiscoreLine(); state=STATE.TITLE;
  }
  function finishOver(){ if(state!==STATE.PLAY)return; state=STATE.OVER; hud.classList.add('hidden'); joy.classList.add('hidden'); over.classList.remove('hidden'); beep('dead'); }
  function finishClear(){
    if(state!==STATE.PLAY)return; state=STATE.CLEAR; hud.classList.add('hidden'); joy.classList.add('hidden'); clear.classList.remove('hidden');
    const newTime=stats.playTime,newKills=stats.enemiesDefeated; let improved=false;
    if(hiscore.bestTime==null||newTime<hiscore.bestTime){ hiscore.bestTime=newTime; improved=true; }
    if(newKills>hiscore.bestKills){ hiscore.bestKills=newKills; improved=true; }
    if(improved) localStorage.setItem(LS_KEY,JSON.stringify(hiscore));
    clearStats.textContent=`撃破数: ${stats.enemiesDefeated}\nクリア時間: ${(stats.playTime/1000).toFixed(1)}s\n取得アイテム: ${stats.itemsAttached}\nスコア: ${stats.score}\nベスト: ${(hiscore.bestTime/1000).toFixed(1)}s / 撃破 ${hiscore.bestKills}`;
    beep('pickup');
  }

  /* ---------- スポーン ---------- */
  function addArrow(dir){ const life=600,w=cv.clientWidth,h=cv.clientHeight,pad=6; const d=DIR8[dir%8];
    let x=(d[0]>0)?(w-pad):((d[0]<0)?pad:w/2), y=(d[1]>0)?(h-pad):((d[1]<0)?pad:h/2); arrows.push({x,y,dir,life}); }
  function edgePos(dir){ const w=cv.clientWidth,h=cv.clientHeight,margin=30,d=DIR8[dir%8];
    let x=(d[0]>0)?w+margin:(d[0]<0?-margin:rnd(0,w)); let y=(d[1]>0)?h+margin:(d[1]<0?-margin:rnd(0,h));
    if(d[0]===0) x=rnd(0,w); if(d[1]===0) y=rnd(0,h); return {x,y}; }
  function spawnEnemy(key){
    const dir=(enemyDirIndex++)%8; addArrow(dir);
    const p=edgePos(dir), base=ENEMY_TYPES[key], d=DIFF[difficultySel.value];
    const hpMul=d.enemyHP*params.enemyHPmul, spdMul=d.enemySpd;
    enemies.push({x:p.x,y:p.y,vx:0,vy:0, hp:Math.round(base.hp*hpMul), hpMax:Math.round(base.hp*hpMul),
      spd:Math.round(base.spd*spdMul), baseR:base.baseR, color:base.color, dmg:base.dmg, type:key, phase:'normal',charge:0,dash:0,hitFx:0});
  }
  function spawnItem(){
    if(attachedItems.length+flyingItems.length>=params.maxItems) return;
    const dir=(itemDirIndex++)%8, p=edgePos(dir);
    const Tb=ITEM_TYPES[Math.floor(Math.random()*ITEM_TYPES.length)];
    const T={...Tb,dur:Math.max(1,Math.round(Tb.dur*params.itemDurMul))};
    const ang=Math.atan2(player.y-p.y,player.x-p.x), speed=120+Math.random()*60;
    flyingItems.push({x:p.x,y:p.y,vx:Math.cos(ang)*speed,vy:Math.sin(ang)*speed,type:T,dur:T.dur});
  }
  function currentWave(){ return WAVES[waveIndex]; }
  function advanceSpawn(dt){
    timers.enemy-=dt; const wv=currentWave(), spMul=DIFF[difficultySel.value].spawnMul;
    if(timers.enemy<=0 && wv && planIndex<wv.plan.length){ spawnEnemy(wv.plan[planIndex++]); timers.enemy+=params.enemyInterval*(1/spMul); }
    if(wv && planIndex>=wv.plan.length && enemies.length===0){ waveIndex++; planIndex=0; if(waveIndex<WAVES.length) waveLabel.textContent=WAVES[waveIndex].name; else finishClear(); }
    timers.item-=dt; if(timers.item<=0){ spawnItem(); timers.item+=params.itemInterval; }
  }

  /* ---------- シェイク ---------- */
  function doShake(mag=6,t=120){ if(!optShake.checked)return; shake.mag=Math.max(shake.mag,mag); shake.t=Math.max(shake.t,t); }
  function getShake(){ return (shake.t>0)?{ox:(Math.random()*2-1)*shake.mag,oy:(Math.random()*2-1)*shake.mag}:{ox:0,oy:0}; }

  /* ---------- 半径/座標 ---------- */
  function itemRadius(obj){ const m=obj.maxDur||obj.type.dur; const ratio=Math.max(0,Math.min(1,obj.dur/m)); return obj.type.baseR*(0.6+0.4*ratio); }
  function enemyRadius(e){ const ratio=Math.max(0,Math.min(1,e.hp/e.hpMax)); return e.baseR*(0.4+0.6*ratio); }
  function worldPos(node){ if(node.parent==='player') return {x:player.x+node.offX,y:player.y+node.offY}; const p=worldPos(node.parent); return {x:p.x+node.offX,y:p.y+node.offY}; }

  /* ---------- ノックバック（インパルス） ---------- */
  function applyKnockback(e, fromX, fromY, kbBase){
    const ang=Math.atan2(e.y-fromY, e.x-fromX);
    const kb=kbBase * params.kbMul;  // 種＋倍率
    const IMPULSE=12;
    e.vx += Math.cos(ang)*kb*IMPULSE;
    e.vy += Math.sin(ang)*kb*IMPULSE;
    if(kb>=30) doShake(6,120);
    e.hitFx=120;
  }

  /* ---------- 更新 ---------- */
  function update(dt){
    time+=dt; stats.playTime+=dt;

    // 代替入力（PC）
    if(!input.active){ let x=0,y=0; if(keys.has('arrowleft')||keys.has('a'))x--; if(keys.has('arrowright')||keys.has('d'))x++; if(keys.has('arrowup')||keys.has('w'))y--; if(keys.has('arrowdown')||keys.has('s'))y++;
      const len=Math.hypot(x,y); input.x=len?x/len:0; input.y=len?y/len:0; }
    stats.comboT-=dt; if(stats.comboT<=0){ stats.combo=1; comboLabel.textContent=''; }

    // プレイヤー
    const sp=+params.playerSpeed;
    player.x=clamp(player.x+input.x*sp*dt/1000, player.r+4, cv.clientWidth-player.r-4);
    player.y=clamp(player.y+input.y*sp*dt/1000, player.r+4, cv.clientHeight-player.r-4);
    if(player.inv>0) player.inv-=dt;

    // 飛来アイテム
    for(let i=flyingItems.length-1;i>=0;i--){
      const it=flyingItems[i], dx=player.x-it.x, dy=player.y-it.y, d=Math.hypot(dx,dy);
      if(d<120){ it.vx+=(dx/d)*60*dt/1000; it.vy+=(dy/d)*60*dt/1000; }
      it.x+=it.vx*dt/1000; it.y+=it.vy*dt/1000;
      const rad=itemRadius(it);

      // プレイヤー接着
      if(hit(it.x,it.y,rad, player.x,player.y,player.r)){
        const ang=Math.atan2(it.y-player.y,it.x-player.x), off=player.r+rad+2;
        attachedItems.push({type:it.type,dur:it.dur,maxDur:it.type.dur,parent:'player',offX:Math.cos(ang)*off,offY:Math.sin(ang)*off});
        stats.itemsAttached++; beep('pickup'); flyingItems.splice(i,1); continue;
      }
      // アイテムへ接続（チェーン）
      let connected=false;
      for(const parentAI of attachedItems){
        const p=worldPos(parentAI);
        if(hit(it.x,it.y,rad, p.x,p.y,itemRadius(parentAI))){
          const ang=Math.atan2(it.y-p.y,it.x-p.x), off=itemRadius(parentAI)+rad+2;
          attachedItems.push({type:it.type,dur:it.dur,maxDur:it.type.dur,parent:parentAI,offX:Math.cos(ang)*off,offY:Math.sin(ang)*off});
          stats.itemsAttached++; beep('pickup'); flyingItems.splice(i,1); connected=true; break;
        }
      }
      if(connected) continue;

      const w=cv.clientWidth,h=cv.clientHeight; if(it.x<-160||it.y<-160||it.x>w+160||it.y>h+160) flyingItems.splice(i,1);
    }

    // 敵（ノックバック減衰＋端クランプ）
    const W=cv.clientWidth,H=cv.clientHeight;
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      // 簡易AI
      if(e.type==='BOSS'){
        if(e.phase==='normal'){ e.charge-=dt; if(e.charge<=0){ e.phase='charge'; e.charge=600; } }
        else if(e.phase==='charge'){ e.charge-=dt; if(e.charge<=0){ e.phase='dash'; e.dash=400; e.dashAng=Math.atan2(player.y-e.y,player.x-e.x); } }
        else if(e.phase==='dash'){ e.dash-=dt; if(e.dash<=0){ e.phase='normal'; e.charge=1800; } }
      }
      let ang=Math.atan2(player.y-e.y,player.x-e.x), spd=e.spd;
      if(e.type==='BOSS'&&e.phase==='dash'){ ang=e.dashAng; spd=e.spd*2.0; }
      if(e.type==='BOSS'&&e.phase==='charge'){ spd=e.spd*0.3; }
      const baseVx=Math.cos(ang)*spd, baseVy=Math.sin(ang)*spd;

      const decay=Math.pow(0.5, dt/300);
      e.vx*=decay; e.vy*=decay;

      e.x += (baseVx + e.vx) * dt/1000;
      e.y += (baseVy + e.vy) * dt/1000;
      if(e.hitFx>0) e.hitFx-=dt;

      const r=enemyRadius(e), pad=2;
      if(e.x<r+pad){ e.x=r+pad; e.vx=Math.abs(e.vx)*0.4; }
      if(e.x>W-r-pad){ e.x=W-r-pad; e.vx=-Math.abs(e.vx)*0.4; }
      if(e.y<r+pad){ e.y=r+pad; e.vy=Math.abs(e.vy)*0.4; }
      if(e.y>H-r-pad){ e.y=H-r-pad; e.vy=-Math.abs(e.vy)*0.4; }

      // 本体衝突
      if(hit(e.x,e.y,r, player.x,player.y,player.r)){
        if(player.inv<=0){ player.hp-=e.dmg; player.inv=700; if(player.hp<=0){ player.hp=0; finishOver(); return; } }
        const pushAng=Math.atan2(e.y-player.y,e.x-player.x);
        e.x+=Math.cos(pushAng)*8; e.y+=Math.sin(pushAng)*8;
      }

      // アイテム命中
      for(let j=attachedItems.length-1;j>=0;j--){
        const ai=attachedItems[j], p=worldPos(ai), ar=itemRadius(ai);
        if(hit(e.x,e.y,r, p.x,p.y,ar)){
          applyKnockback(e, p.x, p.y, ai.type.kb);
          e.hp-=ai.type.atk; beep('hit');
          ai.dur-=1; if(ai.dur<=0) attachedItems.splice(j,1);
          stats.comboT=1200; stats.combo=Math.min(2.0,stats.combo+0.1);
          comboLabel.textContent=(stats.combo>1.01)?`COMBO x${stats.combo.toFixed(1)}`:'';
          if(e.hp<=0){ enemies.splice(i,1); stats.enemiesDefeated++; const gain=10*(ai.type.atk/8)*stats.combo; stats.score+=Math.round(gain); scoreLabel.textContent=`SCORE ${stats.score}`; }
          break;
        }
      }
    }

    // 予告矢印寿命
    for(let k=arrows.length-1;k>=0;k--){ arrows[k].life-=dt; if(arrows[k].life<=0) arrows.splice(k,1); }

    // スポーン
    advanceSpawn(dt);

    // HUD
    lifeFill.style.width=`${(player.hp/player.hpMax)*100}%`;
  }

  /* ---------- 描画 ---------- */
  function draw(){
    const w=cv.clientWidth,h=cv.clientHeight, s=getShake(); ctx.save(); ctx.translate(s.ox,s.oy);
    if(bgCan) ctx.drawImage(bgCan,0,0,w,h);

    // 予告矢印
    for(const a of arrows){ const alpha=Math.max(0,Math.min(1,a.life/600));
      ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle='#fff'; ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.translate(a.x,a.y);
      const angle=Math.atan2(DIR8[a.dir][1],DIR8[a.dir][0]); ctx.rotate(angle);
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-12,-8); ctx.lineTo(-12,8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); }

    // 飛来アイテム
    for(const it of flyingItems) drawItem(it.x,it.y,it.type,it.dur,it.type.dur);

    // 接着アイテム（チェーン）と紐
    ctx.lineWidth=2; ctx.strokeStyle='#ffffff';
    for(const ai of attachedItems){
      const p=worldPos(ai);
      drawItem(p.x,p.y,ai.type,ai.dur,ai.maxDur);
      const parentPos=(ai.parent==='player')?{x:player.x,y:player.y}:worldPos(ai.parent);
      ctx.beginPath(); ctx.moveTo(parentPos.x,parentPos.y); ctx.lineTo(p.x,p.y); ctx.stroke();
    }

    // 敵（黒枠）
    for(const e of enemies){
      const r=enemyRadius(e);
      ctx.save();
      if(e.hitFx>0){ const t=(e.hitFx/120); ctx.shadowColor=`rgba(255,255,255,${0.5*t})`; ctx.shadowBlur=16*t; }
      if(e.type==='BOSS'&&e.phase==='charge'){ const g=0.5+0.5*Math.abs(Math.sin(time/80)); ctx.globalAlpha=g; }
      ctx.fillStyle=e.color; ctx.strokeStyle='#000000'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(e.x,e.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
      // HPバー
      const bw=Math.max(20,r*1.8), bh=6, ratio=Math.max(0,Math.min(1,e.hp/e.hpMax));
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(e.x-bw/2,e.y-r-14,bw,bh);
      ctx.fillStyle='#22c55e'; ctx.fillRect(e.x-bw/2,e.y-r-14,bw*ratio,bh);
      ctx.restore();
    }

    // プレイヤー（黒枠）
    ctx.save(); if(player.inv>0) ctx.globalAlpha=0.35+0.65*Math.abs(Math.sin(time/100));
    ctx.fillStyle='#60a5fa'; ctx.strokeStyle='#000000'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#1f2937'; ctx.beginPath(); ctx.arc(player.x,player.y,6,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // 右上WAVE表示
    ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(w-180,8,172,28);
    ctx.fillStyle='#e6edf3'; ctx.font='bold 14px system-ui, sans-serif';
    const label=currentWave()?currentWave().name:(state===STATE.CLEAR?'CLEAR':'FIN'); ctx.fillText(label,w-170,26);

    ctx.restore();
  }

  function drawItem(x,y,T,dur,maxDur){
    const ratio=Math.max(0,Math.min(1,dur/maxDur)), r=T.baseR*(0.6+0.4*ratio);
    ctx.save(); ctx.translate(x,y);
    ctx.shadowColor=T.color; ctx.shadowBlur=12;
    ctx.fillStyle=T.color; ctx.strokeStyle='#ffffff'; ctx.lineWidth=3; // アイテム枠：白
    if(T.shape==='circle'){
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }else if(T.shape==='tri'){
      ctx.beginPath(); ctx.moveTo(0,-r); ctx.lineTo(r*0.92,r*0.66); ctx.lineTo(-r*0.92,r*0.66); ctx.closePath(); ctx.fill(); ctx.stroke();
    }else{
      const w=r*(T.wh?T.wh[0]:0.7), h=r*(T.wh?T.wh[1]:4.8), rr=Math.max(2,h/4);
      ctx.beginPath();
      ctx.moveTo(-w/2+rr,-h/2); ctx.lineTo(w/2-rr,-h/2);
      ctx.quadraticCurveTo(w/2,-h/2,w/2,-h/2+rr); ctx.lineTo(w/2,h/2-rr);
      ctx.quadraticCurveTo(w/2,h/2,w/2-rr,h/2); ctx.lineTo(-w/2+rr,h/2);
      ctx.quadraticCurveTo(-w/2,h/2,-w/2,h/2-rr); ctx.lineTo(-w/2,-h/2+rr);
      ctx.quadraticCurveTo(-w/2,-h/2,-w/2+rr,-h/2); ctx.closePath();
      ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }

  /* ---------- ループ ---------- */
  function tick(now){
    if(!lastT) lastT=now;
    const dt=Math.max(0,Math.min(50, now-lastT)); lastT=now;
    if(shake && shake.t>0){ shake.t-=dt; if(shake.t<=0){ shake.t=0; shake.mag=0; } }
    if(state===STATE.PLAY){ update(dt); draw(); }
    else { if(bgCan) ctx.drawImage(bgCan,0,0,cv.clientWidth,cv.clientHeight); }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  /* ---------- ボタン ---------- */
  btnStart.addEventListener('click', startGame);
  btnHow.addEventListener('click', ()=>alert([
    '■ルール',
    '・アイテム（◯△▭）は接着上限なし。アイテム同士でも接続（チェーン）できます。',
    '・ノックバックは 1〜10 倍。◯=中 / △=大(強) / ▭=弱。敵のHP/サイズには依存しません。',
    '・ノックバックはインパルス物理で、画面外に出ません。',
    '・敵はダメージで縮小、HP0で消滅。敵HP倍率・アイテム耐久倍率は調整可。',
    '■操作：右下のスティック（PCは矢印/WASD）'
  ].join('\n')));
  btnRetry1.addEventListener('click', backToTitle);
  btnRetry2.addEventListener('click', backToTitle);
  btnRestart1.addEventListener('click', startGame);
  btnRestart2.addEventListener('click', startGame);

  /* ---------- スクロール誤操作防止 ---------- */
  document.addEventListener('touchmove',e=>{ if(state===STATE.PLAY) e.preventDefault(); },{passive:false});

  /* ---------- ★ 安全ガード：初期は必ずタイトル表示 ---------- */
  // 何らかの理由で hidden が付いてしまっていた場合の保険
  requestAnimationFrame(()=>{
    if(state!==STATE.PLAY){
      title.classList.remove('hidden');
      hud.classList.add('hidden');
      joy.classList.add('hidden');
    }
  });
})();
</script>
</body>
</html>
