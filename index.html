<!DOCTYPE html><html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Attach-Attack — 見下ろしアクション</title>
  <style>
    body{margin:0;background:#0a0f16;color:#e6edf3;font-family:sans-serif;overflow:hidden}
    #wrap{display:grid;grid-template-rows:auto 1fr;height:100%}
    header{padding:8px 12px;background:#0f172a;border-bottom:1px solid #1f2937;}
    canvas{width:100%;height:100%;display:block;touch-action:none;background:#070a12}
    .joy{position:absolute;right:16px;bottom:16px;width:140px;height:140px;}
    .joy .base{position:absolute;inset:0;border-radius:50%;background:#0b1220aa;border:1px solid #273244}
    .joy .stick{position:absolute;left:50%;top:50%;width:72px;height:72px;margin-left:-36px;margin-top:-36px;border-radius:50%;background:#1f2937cc;border:1px solid #334155}
  </style>
</head>
<body>
  <div id="wrap">
    <header><h1>Attach-Attack</h1></header>
    <canvas id="cv" width="1280" height="720"></canvas>
    <div class="joy" id="joy"><div class="base"></div><div class="stick" id="stick"></div></div>
  </div>
  <script>
// === Utility ===
const rand=(a,b)=>Math.random()*(b-a)+a; const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)); const dist=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);// === Canvas / Arena (非スクロール) === const cv=document.getElementById('cv'); const ctx=cv.getContext('2d'); const ARENA={ w:cv.clientWidth, h:cv.clientHeight }; function resize(){ const dpr=window.devicePixelRatio||1; cv.width=Math.round(cv.clientWidthdpr); cv.height=Math.round(cv.clientHeightdpr); ctx.setTransform(dpr,0,0,dpr,0,0); ARENA.w=cv.clientWidth; ARENA.h=cv.clientHeight; centerPlayer(); } new ResizeObserver(resize).observe(cv); resize();

// === Input: 右スティック === const joy=document.getElementById('joy'); const stick=document.getElementById('stick'); let joyDX=0, joyDY=0, joyAct=false; function joyHandle(e){ const r=joy.getBoundingClientRect(); const p=e.touches?e.touches[0]:e; const x=p.clientX-r.left-r.width/2; const y=p.clientY-r.top-r.height/2; const rad=r.width/2-8; const len=Math.hypot(x,y); const s=len>rad?rad/len:1; joyDX=(xs)/rad; joyDY=(ys)/rad; stick.style.transform=translate(${joyDX*rad}px,${joyDY*rad}px); } joy.addEventListener('pointerdown',e=>{ joyAct=true; joy.setPointerCapture(e.pointerId); joyHandle(e); }); joy.addEventListener('pointermove',e=>{ if(joyAct) joyHandle(e); }); joy.addEventListener('pointerup',e=>{ joyAct=false; joyDX=joyDY=0; stick.style.transform='translate(0,0)'; });

// === Player === const player={ x:ARENA.w/2, y:ARENA.h/2, r:18, speed:240, life:100, dir:0, inv:0, items:[] }; function centerPlayer(){ player.x=ARENA.w/2; player.y=ARENA.h/2; }

// === Items（○弱/耐久強, △強/耐久中, 長方形中/耐久弱） === const ITEM_KIND={ circle:{atk:14, dur:140}, triangle:{atk:26, dur:90}, rect:{atk:19, dur:70} }; const SHAPES=['circle','triangle','rect']; function makeItem(shape,x,y){ const size=rand(44,76); const stat=ITEM_KIND[shape]; return {shape,size,x,y,vx:0,vy:0,angle:0,attached:false,parent:null,off:rand(30,54),atk:stat.atk, maxDur:stat.dur, dur:stat.dur, flying:true, life:8}; }

const items=[]; // ground/flying + attachedも同一リストで持つ（attachedはplayer.itemsにも入る）

function attachTo(target,it){ if(player.items.length>=3) return false; it.attached=true; it.flying=false; it.parent=target; it.angle=player.dir; it.off=Math.max(26,it.size*0.6); if(!player.items.includes(it)) player.items.push(it); return true; }

// === Enemies（全方向から順次出現） === function makeEnemy(x,y){ return {x,y,r:18,hp:70, vx:0,vy:0}; } const enemies=[]; let enemyTimer=0, enemyInterval=1.4; // 順番に出現

function spawnEnemyFromEdge(){ const side=Math.floor(rand(0,4)); let x=0,y=0; if(side===0){x=rand(0,ARENA.w);y=-20;} if(side===1){x=ARENA.w+20;y=rand(0,ARENA.h);} if(side===2){x=rand(0,ARENA.w);y=ARENA.h+20;} if(side===3){x=-20;y=rand(0,ARENA.h);} enemies.push(makeEnemy(x,y)); }

// === Item spawn（全方向から時間で飛来。開始時に1つ即時） === let itemTimer=0, itemInterval=4.5; let started=false; function spawnItemFromEdge(immediate=false){ const shape=SHAPES[Math.floor(rand(0,SHAPES.length))]; const side=Math.floor(rand(0,4)); let x=0,y=0; if(side===0){x=rand(0,ARENA.w);y=-24;} if(side===1){x=ARENA.w+24;y=rand(0,ARENA.h);} if(side===2){x=rand(0,ARENA.w);y=ARENA.h+24;} if(side===3){x=-24;y=rand(0,ARENA.h);} const it=makeItem(shape,x,y); const a=Math.atan2(player.y-y, player.x-x); const sp=220; it.vx=Math.cos(a)*sp; it.vy=Math.sin(a)*sp; it.angle=a; items.push(it); if(immediate){ it.life=10; } }

// 初回：スタートと同時に1個 spawnItemFromEdge(true);

// === Update === let t0=performance.now(); function update(dt){ // 移動 let ax=joyDX, ay=joyDY; const len=Math.hypot(ax,ay)||1; ax/=len; ay/=len; player.x+=axplayer.speeddt; player.y+=ayplayer.speeddt; player.x=clamp(player.x,player.r,ARENA.w-player.r); player.y=clamp(player.y,player.r,ARENA.h-player.r); if(ax||ay) player.dir=Math.atan2(ay,ax);

// 敵出現（順番に） enemyTimer-=dt; if(enemyTimer<=0){ spawnEnemyFromEdge(); enemyTimer=enemyInterval; }

// 敵AI：プレイヤーへ直進 for(const e of enemies){ const a=Math.atan2(player.y-e.y, player.x-e.x); const sp=100; e.vx=Math.cos(a)sp; e.vy=Math.sin(a)sp; e.x+=e.vxdt; e.y+=e.vydt; }

// アイテム飛来 itemTimer-=dt; if(itemTimer<=0){ spawnItemFromEdge(); itemTimer=itemInterval; } for(const it of items){ if(it.flying){ it.x+=it.vxdt; it.y+=it.vydt; it.life-=dt; if(it.life<=0){ it.flying=false; } } // 自動装着：プレイヤーまたは装着済みアイテムに接触 if(!it.attached){ if(dist(it.x,it.y,player.x,player.y) < player.r + it.size0.45){ attachTo(player,it); } else { for(const at of player.items){ if(dist(it.x,it.y,at.x,at.y) < (at.size0.5 + it.size*0.45)){ attachTo(at,it); break; } } } } }

// 装着アイテムの位置（扇形に配置） for(let i=0;i<player.items.length;i++){ const it=player.items[i]; const par=it.parent||player; const targetAng=(par===player? player.dir : par.angle); const spread=(player.items.length>1? (i-(player.items.length-1)/2)*0.5:0); it.angle+= (targetAng+spread - it.angle)*0.25; it.x=par.x+Math.cos(it.angle)*it.off; it.y=par.y+Math.sin(it.angle)*it.off; }

// 当たり判定：装着アイテム vs 敵（ダメージ＆耐久消耗） for(const e of enemies){ for(const it of player.items){ const rr=it.size0.45; if(dist(e.x,e.y,it.x,it.y) < e.r + rr){ const dmg=it.atkdt2.2; e.hp-=dmg; it.dur-=dmg0.9; if(it.dur<0) it.dur=0; } } } // 敵がプレイヤーに接触 for(const e of enemies){ if(dist(e.x,e.y,player.x,player.y) < e.r + player.r){ if(player.inv<=0){ player.life-=12; player.inv=0.8; } const a=Math.atan2(player.y-e.y, player.x-e.x); player.x+=Math.cos(a)*14; player.y+=Math.sin(a)*14; } } if(player.inv>0) player.inv-=dt;

// アイテム破壊 for(let i=player.items.length-1;i>=0;i--){ const it=player.items[i]; if(it.dur<=0){ player.items.splice(i,1); } }

// 敵消滅 for(let i=enemies.length-1;i>=0;i--){ if(enemies[i].hp<=0){ enemies.splice(i,1); } } }

// === Draw === function draw(){ ctx.clearRect(0,0,cv.width,cv.height); // 背景グリッド ctx.strokeStyle='rgba(96,165,250,0.08)'; ctx.lineWidth=1; ctx.beginPath(); for(let x=0;x<ARENA.w;x+=64){ ctx.moveTo(x,0); ctx.lineTo(x,ARENA.h);} for(let y=0;y<ARENA.h;y+=64){ ctx.moveTo(0,y); ctx.lineTo(ARENA.w,y);} ctx.stroke(); // アイテム（未装着） for(const it of items){ if(!it.attached) drawItem(it); } // プレイヤー ctx.fillStyle = player.inv>0? 'rgba(96,165,250,0.9)':'#cbd5e1'; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI2); ctx.fill(); // 装着アイテム for(const it of player.items){ drawItem(it,true); // true => attached // 中心から線 ctx.strokeStyle='rgba(148,163,184,0.35)'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(player.x,player.y); ctx.lineTo(it.x,it.y); ctx.stroke(); } // 敵 ctx.fillStyle='#f87171'; for(const e of enemies){ ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI2); ctx.fill(); } }

function drawItem(it,attached=false){ const scale = attached? (0.6 + 0.4clamp(it.dur/it.maxDur,0,1)) : 1.0; const s=it.sizescale; ctx.save(); ctx.translate(it.x,it.y); ctx.rotate(it.angle); if(attached) ctx.shadowColor='#60a5fa66', ctx.shadowBlur=10; if(it.shape==='circle'){ ctx.fillStyle = attached? '#86efac' : '#34d399'; ctx.beginPath(); ctx.arc(0,0,s0.5,0,Math.PI2); ctx.fill(); } else if(it.shape==='triangle'){ ctx.fillStyle = attached? '#93c5fd' : '#60a5fa'; ctx.beginPath(); ctx.moveTo(-s0.5, s0.4); ctx.lineTo(0,-s0.55); ctx.lineTo(s0.5, s0.4); ctx.closePath(); ctx.fill(); } else { ctx.fillStyle = attached? '#fca5a5' : '#f87171'; ctx.fillRect(-s0.6,-s0.22,s1.2,s0.44); } if(attached){ // 耐久リング ctx.strokeStyle='rgba(203,213,225,0.8)'; ctx.lineWidth=2; const k=clamp(it.dur/it.maxDur,0,1); ctx.beginPath(); ctx.arc(0,0, Math.max(16, s0.6), -Math.PI/2, -Math.PI/2 + Math.PI2k ); ctx.stroke(); } ctx.restore(); }

// === Loop === function loop(){ const nt=performance.now(); const dt=(nt-t0)/1000; t0=nt; update(dt); draw(); requestAnimationFrame(loop);} loop();

// スクロール抑止 addEventListener('touchmove', e=>{ if(e.target.closest('canvas, #joy')) e.preventDefault(); }, {passive:false}); </script>

</body>
</html>
